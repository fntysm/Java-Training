DATA TYPES:
        short value=187; // -32768 to 32767 
        byte age=18; // from -128 to 127, default: 0
        long range = -42332200000L;
        char favLetter='Z';
        char $favLetter='\u0093';
        char _favLetter=65;
        int binary=0b1101;
        int hexa=0xd582;
        int octal=047;
        boolean happy; // default: false
        // n*10^k; nek;
        double myFloatingFreaking=17.58e2;
        float gpa=5.6F;
        String persona="folklore";
        System.out.println(_favLetter);
OPERATORS:
        we can include different numeric data types in the arithmetic operation
        we can do this will all the arithmetic op: *=	<=> a *= b;	<=> a = a * b;, they are assignment ops;
        Relational operators are used to check the relationship between two operands.
        and Logical ones && || !
        both the same as C language ops;
        Unary operators are used with only one operand, ++num;
        !value	Logical complement operator: inverts the value of a boolean
        Bitwise operators in Java are used to perform operations on individual bits.
Operator	Description
   ~	    Bitwise Complement
  <<	    Left Shift
  >>	    Right Shift
  >>>	    Unsigned Right Shift
   &	    Bitwise AND
   ^	    Bitwise exclusive OR: XOR
        The instanceof operator checks whether an object is an instanceof a particular class.
        objectName instanceOf className;
        We can use the instanceof operator to check if objects of the subclass is also an instance of the superclass.
        and also check whether an object of a class is also an instance of the interface implemented by the class.
// Java program to check if an object of a class is also
//  an instance of the interface implemented by the class

interface Animal {
}

class Dog implements Animal {
}


Ternary Operator:
variable = Expression ? expression1 : expression2
code ;
       short binary=~0b001101;
       short var=0b001101&0b001001;
       System.out.println(binary);

A block is a group of statements (zero or more) that is enclosed in curly braces { }

Control Flow Statements: 
    if(5>7){
        System.out.print("falseeeee");
     }
     else if(6<8){
        System.out.print("5<7");
     }
     else{
        System.out.println(null);
     }
these above obviously aren't nested, but in java we can have if statements nested as well

Switch statement: the same as C
switch (expression) {

  case value1:
    // code
    break;
  
  case value2:
    // code
    break;
  
  ...
  ...
  
  default:
    // default statements
  }


input:
     // create a scanner object
     Scanner input=new Scanner(System.in);
     System.out.println("Enter your age");
     int age=input.nextInt();
     // close the scanner object
     System.out.print("so your age is : "+age+", good.");
     input.close();
for loop: 
for (initialExpression; testExpression; updateExpression) {
    // body of the loop
}
for(i=0; i<5; i++)

Java for-each Loop:
    // create an array
    int[] numbers = {3, 7, 5, -5};
    
    // iterating through the array 
    for (int number: numbers) {
       System.out.println(number);
    }
While loop:
    while (testExpression) {
    // body of loop
}
do {
    // body of loop
} while(textExpression);

break and continue:
The break statement in Java terminates the loop immediately, and the control of the program moves to the next statement following the innermostloop.
in nested loops:
we have used the label identifier to specify the outer loop. (break label;).
break second;

The continue statement skips the current iteration of a loop (for, while, do...while, etc).

In the case of nested loops in Java, the continue statement skips the current iteration of the innermost loop.
continue label;


ARRAYS:
String[] array = new String[100];

// declare an array
double[] data;
// allocate memory
data = new double[10];

double[] data = new double[10];

//declare and initialize and array
int[] age = {12, 4, 5, 2, 5};

Array indices always start from 0

age.length=5;

MATRICES:
double[][] matrix = {{1.2, 4.3, 4.0}, 
      {4.1, -1.1}
};

int[][] array = new int[3][4];
String[][][] data = new String[3][4][2];

// test is a 3d array
int[][][] test = {
        {
          {1, -2, 3}, 
          {2, 3, 4}
        }, 
        { 
          {-4, -5, 6, 9}, 
          {1}, 
          {2, 3}
        } 
};
Basically, a 3d array is an array of 2d arrays. The rows of a 3d array can also vary in length just like in a 2d array.

        int[][] a = {
            {1, -2, 3}, 
            {-4, -5, 6, 9}, 
            {7}, 
        };
      
        // first for...each loop access the individual array
        // inside the 2d array
        for (int[] innerArray: a) {
            // second for...each loop access each element inside the row
            for(int data: innerArray) {
                System.out.println(data);
            }
        }


1. Copying Arrays Using Assignment Operator
int [] numbers = {1, 2, 3, 4, 5, 6};
int [] positiveNumbers = numbers;   
If we change elements of the first array, corresponding elements of the other (copied) arrays also change.

2. Using Looping Construct to Copy Arrays

// this is good:  System.out.println(Arrays.toString(destination));

3. Copying Arrays Using arraycopy() method
import java.util.Arrays;

arraycopy(Object src, int srcPos,Object dest, int destPos, int length)
src - source array you want to copy
srcPos - starting position (index) in the source array
dest - destination array where elements will be copied from the source
destPos - starting position (index) in the destination array
length - number of elements to copy

4. Copying Arrays Using copyOfRange() method
int[] destination1 = Arrays.copyOfRange(source, 0, source.length);   

 int[][] source = {
              {1, 2, 3, 4}, 
              {5, 6},
              {0, 2, 42, -4, 5}
              };

        int[][] destination = new int[source.length][];

        for (int i = 0; i < destination.length; ++i) {

            // allocating space for each row of destination array
            destination[i] = new int[source[i].length];

            for (int j = 0; j < destination[i].length; ++j) {
                destination[i][j] = source[i][j];
            }
        }
     
        // displaying destination array
        System.out.println(Arrays.deepToString(destination));  
Copying 2d Arrays using arraycopy()
       int[][] destination = new int[source.length][];

        for (int i = 0; i < source.length; ++i) {

             // allocating space for each row of destination array
             destination[i] = new int[source[i].length];
             System.arraycopy(source[i], 0, destination[i], 0, destination[i].length);
        }


Methods:
 
modifier static returnType nameOfMethod (parameter1: formal arg(and in the main: actual arg, and they should match), parameter2, ...) {
  // method body
}
Getter: A method that allows you to access an attribute in a given class.
Setter: A method that allows you to set or mutate the value of an attribute in a class.
modifier: the access type

public - This means it can be accessed by other classes.
private - This means it can not
You cannot set the access modifier of getters methods.

Modifier	Description
Default	        declarations are visible only within the package (package private)
Private	        declarations are visible within the class only
Protected	declarations are visible within the package or all subclasses
Public	        declarations are visible everywhere
package defaultPackage;
class Logger {
    void message(){
        System.out.println("This is a message");
    }
}



static: it can be accessed without creating objects

In Java, two or more methods may have the same name if they differ in parameters 
(different number of parameters, different types of parameters, or both). These methods are called overloaded methods and this feature is called method overloading.

Java Constructors:
Unlike Java methods, a constructor has the same name as that of the class and does not have any return type. For example,

class Test {
  Test() {
    // constructor body
  }
}
Here, Test() is a constructor. It has the same name as that of the class and doesn't have a return type.
the constructor does not accept any parameters. Hence, it is known as a no-arg constructor.
Once a constructor is declared private, it cannot be accessed from outside the class. So, creating objects from outside the class is prohibited using the private constructor.
However, if we want to create objects outside the class, then we need to declare the constructor as public.

Parameterized constructor
class Main {

  String languages;

  // constructor accepting single value
  Main(String lang) {
    languages = lang;
    System.out.println(languages + " Programming Language");
  }

  public static void main(String[] args) {

    // call constructor by passing a single value
    Main obj1 = new Main("Java");
    Main obj2 = new Main("Python");
    Main obj3 = new Main("C");
  }
}


A constructor cannot be abstract or static or final.
A constructor can be overloaded but can not be overridden.


Java Strings:
all string variables are instances of the String class.
ops: 
int length = greet.length();
String joinedString = first.concat(second);
boolean result = first.equals(second);
In Java, strings are immutable.

so we use the new keyword: 
// create a string using the new keyword
Here, we are directly providing the value of the string (Java). Hence, the compiler first checks the string pool to see if the string already exists.

If the string already exists, the new string is not created. Instead, the new reference, example points to the already existed string (Java).
If the string doesn't exist, the new string (Java is created.
2. While creating strings using the new keyword,

String example = new String("Java");
Here, the value of the string is not directly provided. Hence, a new "Java" string is created even though "Java" is already present inside the memory pool.


Methods	        Description
contains()	checks whether the string contains a substring
substring()	returns the substring of the string
join()	join the given strings using the delimiter
replace()	replaces the specified old character with the specified new character
replaceAll()	replaces all substrings matching the regex pattern
replaceFirst()	replace the first matching substring
charAt()	returns the character present in the specified location
getBytes()	converts the string to an array of bytes
indexOf()	returns the position of the specified character in the string
compareTo()	compares two strings in the dictionary order
compareToIgnoreCase()	compares two strings ignoring case differences
trim()	removes any leading and trailing whitespaces
format()	returns a formatted string
split()	breaks the string into an array of strings
toLowerCase()	converts the string to lowercase
toUpperCase()	converts the string to uppercase
valueOf()	returns the string representation of the specified argument
toCharArray()	converts the string to a char array
matches()	checks whether the string matches the given regex
startsWith()	checks if the string begins with the given string
endsWith()	checks if the string ends with the given string
isEmpty()	checks whether a string is empty of not
intern() 	returns the canonical representation of the string
contentEquals()	checks whether the string is equal to charSequence
hashCode()	returns a hash code for the string
subSequence()	returns a subsequence from the string



instance variables and parameters may have the same name. For example,

class MyClass {
    // instance variable
    int age;

    // parameter
    MyClass(int age){
        this.age = age;
    }
}


While working with constructor overloading, we might have to invoke one constructor from another constructor. In such a case, we cannot call the constructor explicitly. Instead, we have to use this keyword.

Here, we use a different form of this keyword. That is, this(). Let's take an example,

class Complex {

    private int a, b;

    // constructor with 2 parameters
    private Complex( int i, int j ){
        this.a = i;
        this.b = j;
    }

    // constructor with single parameter
    private Complex(int i){
        // invokes the constructor with 2 parameters
        this(i, i); 
    }

    // constructor with no parameter
    private Complex(){
        // invokes the constructor with single parameter
        this(0);
    }

    @Override
    public String toString(){
        return this.a + " + " + this.b + "i";
    }


final:
Once any entity (variable, method or class) is declared final, it can be assigned only once.
final int age = 22;

method overriding occurs when a subclass (child class) has the same method as the parent class. 
In other words, method overriding occurs when a subclass provides a particular implementation of a method declared by one of its parent classes.

the final method cannot be overridden by the child class.
the final class cannot be inherited by another class.
// create a final class
final class FinalClass {
  public void display() {
    System.out.println("This is a final method.");
  }
}

// try to extend the final class
class Main extends FinalClass {
..



